{% extends "system/base.html" %}
{% block title %}Callsheet{% endblock %}
{% block content %}
<div class="container-fluid">
    <div class="row mb-4">
        <div class="col">
            <h2>Callsheet</h2>
            <a href="{{ url_for('game_options') }}" class="btn btn-secondary">Back to Games</a>
            <button id="export-pdf" class="btn btn-info">Export as PDF</button>
        </div>
    </div>

    <!-- Wrap the content to export in a specific div -->
    <div id="export-content">
        <div class="row">
            <div class="col">
                <div class="table-responsive">
                    <table id="callsheet-table" class="table table-striped table-bordered">
                        <thead>
                            <tr>
                                <!-- Added class "sortable" for columns that should be sorted -->
                                <th class="sortable">Offense Play</th>
                                <th class="sortable">Offense Formation</th>
                                <th class="sortable">Formation Adjustment</th>
                                <th class="sortable">Count</th>
                                <th class="sortable">Percent</th>
                                <th><!-- column for the bar; not sortable --></th>
                                <th class="sortable">Total</th>
                                <th class="sortable">Average</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for entry in callsheet_entries %}
                            <tr>
                                <td>{{ entry.off_play }}</td>
                                <td>{{ entry.off_form }}</td>
                                <td>{{ entry.form_adj }}</td>
                                <td>{{ entry.count }}</td>
                                <td>{{ "%.2f"|format(entry.percent) }}%</td>
                                <td>
                                    <!-- Bar representation -->
                                    <div style="width: 150px; background-color: #e0e0e0; border-radius: 1px;">
                                        <div style="width: {{ entry.percent }}%; height: 20px; background-color: #00c4ff; border-radius: 1px;"></div>
                                    </div>
                                </td>
                                <td>{{ entry.total }}</td>
                                <td>{{ "%.2f"|format(entry.average) }}</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Optional CSS to indicate clickable headers -->
<style>
    th.sortable {
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    th.sortable:hover {
        background-color: #f1f1f1;
    }
</style>

<!-- Include jsPDF and html2canvas libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<!-- Sorting functionality script with arrow icons -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    const table = document.getElementById('callsheet-table');
    const sortableHeaders = table.querySelectorAll('th.sortable');

    // Store the original text for each header so we can reapply it later.
    sortableHeaders.forEach(header => {
        header.dataset.originalText = header.textContent.trim();
    });

    sortableHeaders.forEach(header => {
        header.addEventListener('click', () => {
            // Get the actual column index (accounting for unsortable columns)
            const actualIndex = Array.from(header.parentNode.children).indexOf(header);
            // Toggle sort order: default to ascending if not set, otherwise switch between 'asc' and 'desc'
            let currentOrder = header.getAttribute('data-sort-order') || 'asc';
            let newOrder = currentOrder === 'asc' ? 'desc' : 'asc';

            // Reset sort order attribute and text on all sortable headers.
            sortableHeaders.forEach(h => {
                h.removeAttribute('data-sort-order');
                h.innerHTML = h.dataset.originalText;
            });

            // Set the new sort order on the clicked header and update its text with an arrow.
            header.setAttribute('data-sort-order', newOrder);
            // When sorted ascending, show a down arrow (▼); when descending, show an up arrow (▲).
            let arrow = newOrder === 'asc' ? "&#x25BC;" : "&#x25B2;";
            header.innerHTML = header.dataset.originalText + ' ' + arrow;

            sortTableByColumn(table, actualIndex, newOrder);
        });
    });

    /**
     * Sorts the table rows based on the content in the specified column index.
     * It attempts a numeric sort (removing '%' and commas) if possible,
     * otherwise falls back to string comparison.
     *
     * @param {HTMLTableElement} table - The table element.
     * @param {number} colIndex - The actual column index to sort by.
     * @param {string} sortOrder - 'asc' for ascending order, 'desc' for descending order.
     */
    function sortTableByColumn(table, colIndex, sortOrder = 'asc') {
        const tbody = table.querySelector('tbody');
        const rowsArray = Array.from(tbody.querySelectorAll('tr'));

        rowsArray.sort((rowA, rowB) => {
            const cellA = rowA.children[colIndex].innerText.trim();
            const cellB = rowB.children[colIndex].innerText.trim();

            // Remove any '%' and commas for numeric comparison
            const numA = parseFloat(cellA.replace('%','').replace(/,/g, ''));
            const numB = parseFloat(cellB.replace('%','').replace(/,/g, ''));

            let comparison;
            if (!isNaN(numA) && !isNaN(numB)) {
                comparison = numA - numB;
            } else {
                comparison = cellA.localeCompare(cellB);
            }

            return sortOrder === 'asc' ? comparison : -comparison;
        });

        // Reattach the sorted rows back to the tbody.
        rowsArray.forEach(row => tbody.appendChild(row));
    }
});
</script>

<!-- PDF Export functionality remains unchanged -->
<script>
document.getElementById('export-pdf').addEventListener('click', function () {
    const currentTime = new Date().toLocaleString();
    const element = document.getElementById('export-content');

    // Use a higher scale for improved sharpness.
    const scale = 1.8;
    const options = {
        scale: scale,
        useCORS: true,
        logging: false,
        allowTaint: true,
        backgroundColor: '#ffffff'
    };

    html2canvas(element, options).then(function (canvas) {
        const pdf = new jspdf.jsPDF('p', 'mm', 'a4');

        // Define explicit margins (in mm).
        const marginLeft = 15;
        const marginRight = 15;
        const marginTop = 25;  // Top margin for first page.
        const marginBottom = 20;
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const contentWidth = pageWidth - marginLeft - marginRight;

        // --- Single Header on First Page ---
        pdf.setFontSize(18);
        pdf.setFont('helvetica', 'bold');
        pdf.text('Callsheet Report', marginLeft, marginTop - 10);
        pdf.setFontSize(12);
        pdf.text(`Exported: ${currentTime}`, marginLeft, marginTop);

        // --- Calculate dimensions ---
        const pdfImgHeight = canvas.height * (contentWidth / canvas.width);
        const pxPerMm = canvas.height / pdfImgHeight;

        // Available heights (no header space reserved).
        const availableHeightFirstPage = pageHeight - marginTop - marginBottom;
        const availableHeightOtherPages = pageHeight - marginTop - marginBottom;

        // Split content into pages.
        const pages = [];
        let remainingPx = canvas.height;
        let currentY = 0;

        // First page (starts immediately after header).
        let firstPagePx = availableHeightFirstPage * pxPerMm;
        pages.push({ startY: currentY, height: Math.min(firstPagePx, canvas.height) });
        currentY += firstPagePx;
        remainingPx -= firstPagePx;

        // Subsequent pages.
        const otherPagePx = availableHeightOtherPages * pxPerMm;
        while (remainingPx > 0) {
            let h = Math.min(otherPagePx, remainingPx);
            pages.push({ startY: currentY, height: h });
            currentY += h;
            remainingPx -= h;
        }

        // Helper function to create a cropped canvas.
        function getCroppedCanvas(sourceCanvas, cropY, cropHeight) {
            var croppedCanvas = document.createElement('canvas');
            croppedCanvas.width = sourceCanvas.width;
            croppedCanvas.height = cropHeight;
            var ctx = croppedCanvas.getContext('2d');
            ctx.drawImage(sourceCanvas, 0, cropY, sourceCanvas.width, cropHeight,
                        0, 0, sourceCanvas.width, cropHeight);
            return croppedCanvas;
        }

        // Add pages.
        pages.forEach((page, index) => {
            if (index > 0) pdf.addPage();

            const cropped = getCroppedCanvas(canvas, page.startY, page.height);
            const imgData = cropped.toDataURL('image/jpeg', 0.7);
            const imgHeightMm = page.height / pxPerMm;

            // First page content starts right after header.
            const yPosition = index === 0 ? marginTop + 10 : marginTop;
            pdf.addImage(imgData, 'JPEG', marginLeft, yPosition, contentWidth, imgHeightMm);
        });

        pdf.save('callsheet.pdf');
    });
});
</script>
{% endblock %}
