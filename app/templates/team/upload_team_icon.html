{% extends "system/base.html" %}

{% block head %}
<script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>
<style>
  .top-back-btn {
    position: absolute;
    top: 70px;
    left: 20px;
    z-index: 1050;
  }
</style>
{% endblock %}

{% block content %}
<div class="text-start ps-4 mt-4">
  <a href="{{ url_for('team.choose_creation_method') }}" class="btn btn-secondary rounded px-4 py-2">
    Back
  </a>
</div>

<div class="container mt-5 text-center">
  <h2 class="mb-4">Upload Your Team Icon</h2>

  <!-- Step 1: Upload Image -->
  <div id="step-upload">
    <p class="lead">Use a transparent PNG or SVG.</p>

    <div class="my-3">
      <svg id="icon-preview" width="300" height="300" viewBox="0 0 300 300"
           class="border rounded" xmlns="http://www.w3.org/2000/svg">
      </svg>
    </div>

    <input type="file" name="icon" id="icon-upload" accept=".png,.svg"
           class="form-control mb-3 mx-auto" style="max-width: 300px;" required>
    <button class="btn btn-primary mt-2" id="btn-to-color" disabled>Next</button>
  </div>

  <!-- Step 2: Color Picker -->
  <div id="step-colors" style="display: none;">
    <h4 class="mb-4">Choose Primary & Secondary Colors</h4>
    <div class="d-flex justify-content-center gap-4 flex-wrap">
      <div class="d-flex flex-column align-items-center justify-content-center p-3" style="border: 3px solid black; border-radius: 8px; min-width: 220px; min-height: 330px;">
        <p class="fw-bold mb-2">Primary</p>
        <div id="primary-picker" class="mb-2"></div>
        <input type="text" id="primary-hex" class="form-control text-center" readonly style="border: 2px solid black; max-width: 120px;">
      </div>
      <div class="d-flex flex-column align-items-center justify-content-center p-3" style="border: 3px solid black; border-radius: 8px; min-width: 220px; min-height: 330px;">
        <p class="fw-bold mb-2">Secondary</p>
        <div id="secondary-picker" class="mb-2"></div>
        <input type="text" id="secondary-hex" class="form-control text-center" readonly style="border: 2px solid black; max-width: 120px;">
      </div>
    </div>
    <button class="btn btn-primary mt-4" id="btn-to-name">Next</button>
  </div>

  <!-- Step 3: Team Name and Submit -->
  <div id="step-name" style="display: none;">
    <div class="mx-auto mt-4 p-4 border border-dark rounded" style="max-width: 600px;">
      <h4 class="mb-3">Team Name</h4>
      <form id="upload-form" method="POST" action="{{ url_for('team.upload_team_icon_page') }}" enctype="multipart/form-data">
        <input type="text" class="form-control mb-3" name="name" placeholder="Enter team name" required>
        <input type="hidden" name="primary_color" id="form_primary_color">
        <input type="hidden" name="secondary_color" id="form_secondary_color">
        <input type="hidden" name="final_svg" id="final_svg">
        <input type="file" name="icon" id="icon-hidden" style="display: none;" />
        <button type="submit" class="btn btn-success mt-2 px-4">
          <i class="bi bi-cloud-arrow-up"></i> Save Team Icon
        </button>
      </form>
    </div>
  </div>
</div>

<script>
  const uploadInput = document.getElementById("icon-upload");
  const preview = document.getElementById("icon-preview");
  const btnToColor = document.getElementById("btn-to-color");
  const btnToName = document.getElementById("btn-to-name");

  let primaryPicker, secondaryPicker;
  let extractedPrimary = "", extractedSecondary = "";

  function rgbToHex(r, g, b) {
    return "#" + [r, g, b].map(x => {
      const hex = x.toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    }).join("");
  }
 
  function extractColorsFromImage(img, callback) {
  const canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);

  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
  for (let y = 0; y < canvas.height; y++) {
    for (let x = 0; x < canvas.width; x++) {
      const i = (y * canvas.width + x) * 4;
      if (data[i + 3] > 10) {
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
    }
  }

  const boxWidth = maxX - minX + 1;
  const boxHeight = maxY - minY + 1;

  const cropped = ctx.getImageData(minX, minY, boxWidth, boxHeight).data;
  const colorCount = {};

  for (let i = 0; i < cropped.length; i += 4) {
    const [r, g, b, a] = [cropped[i], cropped[i + 1], cropped[i + 2], cropped[i + 3]];
    if (a < 50) continue;
    const key = `${r},${g},${b}`;
    colorCount[key] = (colorCount[key] || 0) + 1;
  }

  const sortedColors = Object.entries(colorCount)
    .sort((a, b) => b[1] - a[1])
    .map(([rgb]) => rgbToHex(...rgb.split(',').map(Number)));

  function isBlackOrWhite(hex) {
    const hexVal = hex.replace("#", "");
    const r = parseInt(hexVal.slice(0, 2), 16);
    const g = parseInt(hexVal.slice(2, 4), 16);
    const b = parseInt(hexVal.slice(4, 6), 16);
    const brightness = (r + g + b) / 3;
    const maxDiff = Math.max(r, g, b) - Math.min(r, g, b);
    return (brightness > 245 || brightness < 20) && maxDiff < 15;
  }

  let nonNeutralColor = null;
  let neutralFallback = null;

  for (let i = 0; i < Math.min(6, sortedColors.length); i++) {
    const color = sortedColors[i];
    if (!isBlackOrWhite(color)) {
      nonNeutralColor = color;
      break;
    } else if (!neutralFallback) {
      neutralFallback = color;
    }
  }

  if (!nonNeutralColor && !neutralFallback) {
    extractedPrimary = "#000000";
    extractedSecondary = "#FFFFFF";
  } else if (!nonNeutralColor && neutralFallback) {
    extractedPrimary = neutralFallback;
    extractedSecondary = neutralFallback;
  } else {
    extractedPrimary = nonNeutralColor;
    extractedSecondary = neutralFallback || "#FFFFFF";
  }

  callback(extractedPrimary, extractedSecondary);
  initializePickers(extractedPrimary, extractedSecondary);
}



  function initializePickers(primary, secondary) {
    const primaryPickerEl = document.getElementById("primary-picker");
    const secondaryPickerEl = document.getElementById("secondary-picker");

    primaryPickerEl.innerHTML = "";
    secondaryPickerEl.innerHTML = "";

    primaryPicker = new iro.ColorPicker(primaryPickerEl, {
      width: 120,
      color: primary
    });
    secondaryPicker = new iro.ColorPicker(secondaryPickerEl, {
      width: 120,
      color: secondary
    });

    document.getElementById("primary-hex").value = primary.toUpperCase();
    document.getElementById("secondary-hex").value = secondary.toUpperCase();

    primaryPicker.on("color:change", function (color) {
      const hex = color.hexString.toUpperCase();
      extractedPrimary = hex;
      document.getElementById("primary-hex").value = hex;
    });

    secondaryPicker.on("color:change", function (color) {
      const hex = color.hexString.toUpperCase();
      extractedSecondary = hex;
      document.getElementById("secondary-hex").value = hex;
    });
  }

  btnToName.addEventListener("click", () => {
    document.getElementById("step-colors").style.display = "none";
    document.getElementById("step-name").style.display = "block";

    document.getElementById("form_primary_color").value = extractedPrimary.toUpperCase();
    document.getElementById("form_secondary_color").value = extractedSecondary.toUpperCase();
  });

  uploadInput.addEventListener("change", function (e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (event) {
      while (preview.lastChild && preview.lastChild.tagName !== "rect") {
        preview.removeChild(preview.lastChild);
      }
      document.getElementById("icon-hidden").files = e.target.files;

      if (file.type === "image/svg+xml") {
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(event.target.result, "image/svg+xml");
        const svgEl = svgDoc.querySelector("svg");
        if (!svgEl) return;
        const imported = document.importNode(svgEl, true);
        imported.setAttribute("width", 200);
        imported.setAttribute("height", 200);
        imported.setAttribute("x", 50);
        imported.setAttribute("y", 50);
        preview.appendChild(imported);
        btnToColor.disabled = false;

        const clone = preview.cloneNode(true);
        clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(clone);
        document.getElementById("final_svg").value = svgString;

      } else if (file.type === "image/png") {
        const img = new Image();
        img.src = event.target.result;
        img.onload = function () {
          const imageEl = document.createElementNS("http://www.w3.org/2000/svg", "image");
          imageEl.setAttribute("href", img.src);
          imageEl.setAttribute("x", 0);
          imageEl.setAttribute("y", 0);
          imageEl.setAttribute("width", 300);
          imageEl.setAttribute("height", 300);
          preview.appendChild(imageEl);

          extractColorsFromImage(img, () => {
            const clone = preview.cloneNode(true);
            clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(clone);
            document.getElementById("final_svg").value = svgString;
            btnToColor.disabled = false;
          });
        };
      }
    };
    reader.readAsDataURL(file);
  });

  btnToColor.addEventListener("click", () => {
    document.getElementById("step-upload").style.display = "none";
    document.getElementById("step-colors").style.display = "block";
  });

  window.onload = function () {
    while (preview.lastChild && preview.lastChild.tagName !== "rect") {
      preview.removeChild(preview.lastChild);
    }
  };
</script>

{% endblock %}
