{% extends "system/base.html" %}
{% block title %}Callsheet{% endblock %}
{% block content %}
<div class="container-fluid">
    <div class="row mb-4">
        <div class="col">
            <h2>Game Callsheet</h2>
            <!-- Filter Area -->
            <div class="row mb-3">
                <!-- Dropdown: Offense Play -->
                <div class="col-md-2">
                    <label for="filter-off_play">Offense Play</label>
                    <select id="filter-off_play" class="form-control filter-dropdown">
                        <option value="">All</option>
                    </select>
                </div>
                <!-- Dropdown: Offense Formation -->
                <div class="col-md-2">
                    <label for="filter-off_form">Offense Formation</label>
                    <select id="filter-off_form" class="form-control filter-dropdown">
                        <option value="">All</option>
                    </select>
                </div>
                <!-- Dropdown: Formation Adjustment -->
                <div class="col-md-2">
                    <label for="filter-form_adj">Formation Adjustment</label>
                    <select id="filter-form_adj" class="form-control filter-dropdown">
                        <option value="">All</option>
                    </select>
                </div>
                <!-- Input: Min Average -->
                <div class="col-md-2">
                    <label for="filter-min-avg">Min Avg</label>
                    <input type="number" step="0.1" id="filter-min-avg" class="form-control filter-input">
                </div>
                <!-- Input: Max Average -->
                <div class="col-md-2">
                    <label for="filter-max-avg">Max Avg</label>
                    <input type="number" step="0.1" id="filter-max-avg" class="form-control filter-input">
                </div>
                <!-- Button: Clear all filters -->
                <div class="col-md-2 d-flex align-items-end">
                    <button id="clear-filters" class="btn btn-secondary w-100">Clear</button>
                </div>
            </div>
            <a href="{{ url_for('dashboard', game_id=game_id) }}" class="btn btn-secondary">Back to Dashboard</a>
            <button id="export-pdf" class="btn btn-info">Export as PDF</button>
        </div>
    </div>
    <br><br>
    <!-- Wrap the content to export in a specific div -->
    <div id="export-content">
        <div class="row">
            <div class="col">
                <div class="table-responsive">
                    <table id="callsheet-table" class="table table-striped table-bordered">
                        <thead>
                            <tr>
                                <!-- Mark headers that should be sortable -->
                                <th class="sortable">Offense Play</th>
                                <th class="sortable">Offense Formation</th>
                                <th class="sortable">Formation Adjustment</th>
                                <th class="sortable">Count</th>
                                <th class="sortable">Percent</th>
                                <th><!-- Bar column; no sorting --></th>
                                <th class="sortable">Total</th>
                                <th class="sortable">Average</th>
                                <th class="sortable">Standard Deviation</th>
                                <th class="sortable">Median</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for entry in callsheet_entries %}
                            <tr>
                                <td>{{ entry.off_play }}</td>
                                <td>{{ entry.off_form }}</td>
                                <td>{{ entry.form_adj }}</td>
                                <td>{{ entry.count }}</td>
                                <td>{{ "%.2f"|format(entry.percent) }}%</td>
                                <td>
                                    <!-- Bar representation -->
                                    <div style="width: 150px; background-color: #e0e0e0; border-radius: 1px;">
                                        <div style="width: {{ entry.percent }}%; height: 20px; background-color: #00c4ff; border-radius: 1px;"></div>
                                    </div>
                                </td>
                                <td>{{ entry.total }}</td>
                                <td>{{ "%.2f"|format(entry.average) }}</td>
                                <td>{{ entry.std_dev| round(2) }}</td>
                                <td>{{ entry.median }}</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Optional CSS to indicate clickable headers -->
<style>
    th.sortable {
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    th.sortable:hover {
        background-color: #f1f1f1;
    }
</style>

<!-- Include jsPDF and html2canvas libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<!-- Sorting functionality with toggle ascending/descending and arrow icons -->
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const table = document.getElementById('callsheet-table');
        // Grab all rows from the table body
        const rows = Array.from(table.querySelectorAll('tbody tr'));
        const sortableHeaders = table.querySelectorAll('th.sortable');
    
        /**
         * Fills a dropdown with values from a specific column in the table.
         * @param {string} id - ID of the dropdown element
         * @param {number} index - Index of the table column to extract values from
         */
        const fillDropdown = (id, index) => {
            const select = document.getElementById(id);
            // Use a Set to collect values
            const values = new Set(rows.map(row => row.children[index].textContent.trim()));
            // Sort the values and add them as <option> elements
            Array.from(values).sort().forEach(val => {
                const opt = document.createElement('option');
                opt.value = val;
                opt.textContent = val;
                select.appendChild(opt);
            });
        };
        // Fill each dropdown with values from the corresponding table column
        fillDropdown('filter-off_play', 0);
        fillDropdown('filter-off_form', 1);
        fillDropdown('filter-form_adj', 2);
    
        // Applies all filters to show/hide rows based on dropdown and input values.
        const applyFilters = () => {
            const playFilter = document.getElementById('filter-off_play').value;
            const formFilter = document.getElementById('filter-off_form').value;
            const adjFilter = document.getElementById('filter-form_adj').value;
            const minAvg = parseFloat(document.getElementById('filter-min-avg').value);
            const maxAvg = parseFloat(document.getElementById('filter-max-avg').value);
    
            rows.forEach(row => {
                const offPlay = row.children[0].textContent.trim();
                const offForm = row.children[1].textContent.trim();
                const formAdj = row.children[2].textContent.trim();
                const avg = parseFloat(row.children[7].textContent.trim());
    
                let visible = true;
    
                // Dropdown filters (skip empty values = "All")
                if (playFilter && playFilter !== offPlay) visible = false;
                if (formFilter && formFilter !== offForm) visible = false;
                if (adjFilter && adjFilter !== formAdj) visible = false;
    
                // Min/Max average filters
                if (!isNaN(minAvg) && avg < minAvg) visible = false;
                if (!isNaN(maxAvg) && avg > maxAvg) visible = false;
    
                // Show or hide row
                row.style.display = visible ? '' : 'none';
            });
        };
    
        // Attach event listeners to all filters
        document.querySelectorAll('.filter-dropdown, .filter-input').forEach(elem => {
            elem.addEventListener('input', applyFilters);
        });
    
        // Clear button to reset all filter fields
        document.getElementById('clear-filters').addEventListener('click', () => {
            document.querySelectorAll('.filter-dropdown, .filter-input').forEach(elem => {
                if (elem.tagName === 'SELECT') elem.value = '';
                else elem.value = '';
            });
            applyFilters();
        });

    // Store the original text for each header so we can reapply it later.
    sortableHeaders.forEach(header => {
        header.dataset.originalText = header.textContent.trim();
    });

    sortableHeaders.forEach(header => {
        header.addEventListener('click', () => {
            // Compute the actual column index (accounting for unsortable columns)
            const actualIndex = Array.from(header.parentNode.children).indexOf(header);
            // Toggle sort order: default to ascending if not set, otherwise switch between 'asc' and 'desc'
            let currentOrder = header.getAttribute('data-sort-order') || 'asc';
            let newOrder = currentOrder === 'asc' ? 'desc' : 'asc';

            // Reset sort order attribute and text on all sortable headers.
            sortableHeaders.forEach(h => {
                h.removeAttribute('data-sort-order');
                h.innerHTML = h.dataset.originalText;
            });

            // Set the new sort order on the clicked header and update its text with an arrow.
            header.setAttribute('data-sort-order', newOrder);
            // When sorted ascending, show a down arrow (▼); when descending, show an up arrow (▲).
            let arrow = newOrder === 'asc' ? "&#x25BC;" : "&#x25B2;";
            header.innerHTML = header.dataset.originalText + ' ' + arrow;

            sortTableByColumn(table, actualIndex, newOrder);
        });
    });

    /**
     * Sorts the table rows based on the content in the specified column index.
     * It attempts a numeric sort (removing '%' and commas) if possible,
     * otherwise falls back to string comparison.
     *
     * @param {HTMLTableElement} table - The table element.
     * @param {number} colIndex - The actual column index to sort by.
     * @param {string} sortOrder - 'asc' for ascending order, 'desc' for descending order.
     */
    function sortTableByColumn(table, colIndex, sortOrder = 'asc') {
        const tbody = table.querySelector('tbody');
        const rowsArray = Array.from(tbody.querySelectorAll('tr'));

        rowsArray.sort((rowA, rowB) => {
            const cellA = rowA.children[colIndex].innerText.trim();
            const cellB = rowB.children[colIndex].innerText.trim();

            // Remove any '%' and commas for numeric comparison
            const numA = parseFloat(cellA.replace('%','').replace(/,/g, ''));
            const numB = parseFloat(cellB.replace('%','').replace(/,/g, ''));

            let comparison;
            if (!isNaN(numA) && !isNaN(numB)) {
                comparison = numA - numB;
            } else {
                comparison = cellA.localeCompare(cellB);
            }

            return sortOrder === 'asc' ? comparison : -comparison;
        });

        // Reattach the sorted rows back to the tbody.
        rowsArray.forEach(row => tbody.appendChild(row));
    }
});
</script>

<!-- PDF Export functionality remains unchanged -->
<script>
document.getElementById('export-pdf').addEventListener('click', function () {
    const currentTime = new Date().toLocaleString();
    const element = document.getElementById('export-content');

    // Use a higher scale for improved sharpness.
    const scale = 1.8;
    const options = {
        scale: scale,
        useCORS: true,
        logging: false,
        allowTaint: true,
        backgroundColor: '#ffffff'
    };

    html2canvas(element, options).then(function (canvas) {
        const pdf = new jspdf.jsPDF('p', 'mm', 'a4');

        // Define explicit margins (in mm)
        const marginLeft = 15;
        const marginRight = 15;
        const marginTop = 25;  // Top margin for first page
        const marginBottom = 20;
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const contentWidth = pageWidth - marginLeft - marginRight;

        // --- Single Header on First Page ---
        pdf.setFontSize(18);
        pdf.setFont('helvetica', 'bold');
        pdf.text('Callsheet Report', marginLeft, marginTop - 10);
        pdf.setFontSize(12);
        pdf.text(`Exported: ${currentTime}`, marginLeft, marginTop);

        // --- Calculate dimensions ---
        const pdfImgHeight = canvas.height * (contentWidth / canvas.width);
        const pxPerMm = canvas.height / pdfImgHeight;

        // Available heights (no header space reserved)
        const availableHeightFirstPage = pageHeight - marginTop - marginBottom;
        const availableHeightOtherPages = pageHeight - marginTop - marginBottom;

        // Split content into pages.
        const pages = [];
        let remainingPx = canvas.height;
        let currentY = 0;

        // First page (starts immediately after header)
        let firstPagePx = availableHeightFirstPage * pxPerMm;
        pages.push({ startY: currentY, height: Math.min(firstPagePx, canvas.height) });
        currentY += firstPagePx;
        remainingPx -= firstPagePx;

        // Subsequent pages
        const otherPagePx = availableHeightOtherPages * pxPerMm;
        while (remainingPx > 0) {
            let h = Math.min(otherPagePx, remainingPx);
            pages.push({ startY: currentY, height: h });
            currentY += h;
            remainingPx -= h;
        }

        // Helper function to create a cropped canvas for each page.
        function getCroppedCanvas(sourceCanvas, cropY, cropHeight) {
            var croppedCanvas = document.createElement('canvas');
            croppedCanvas.width = sourceCanvas.width;
            croppedCanvas.height = cropHeight;
            var ctx = croppedCanvas.getContext('2d');
            ctx.drawImage(sourceCanvas, 0, cropY, sourceCanvas.width, cropHeight,
                        0, 0, sourceCanvas.width, cropHeight);
            return croppedCanvas;
        }

        // Add pages to the PDF.
        pages.forEach((page, index) => {
            if (index > 0) pdf.addPage();

            const cropped = getCroppedCanvas(canvas, page.startY, page.height);
            const imgData = cropped.toDataURL('image/jpeg', 0.7);
            const imgHeightMm = page.height / pxPerMm;

            // First page content starts right after header.
            const yPosition = index === 0 ? marginTop + 10 : marginTop;
            pdf.addImage(imgData, 'JPEG', marginLeft, yPosition, contentWidth, imgHeightMm);
        });

        pdf.save('callsheet.pdf');
    });
});
</script>
{% endblock %}
