\documentclass[12pt]{article}

% Sprache & Kodierung
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

% Seitenlayout
\usepackage{geometry}
\geometry{a4paper, margin=2.5cm}
\usepackage{tabularx}

% Code Listings mit Minted
\usepackage{minted}
\usemintedstyle{default}
\setminted{
    fontsize=\small,
    tabsize=2,
    breaklines=true
}

% Farbige Boxen um Code
\usepackage{tcolorbox}
\usepackage{etoolbox}
\BeforeBeginEnvironment{minted}{\begin{tcolorbox}[colback=gray!5, colframe=gray!30, boxrule=0.5pt, arc=2pt]}
\AfterEndEnvironment{minted}{\end{tcolorbox}}

% Bessere Typografie
\usepackage{microtype}

% Hyperlinks
\usepackage{hyperref}

\title{Dokumentation: Benutzerverwaltungsmodul}
\author{X, Y, 999999999\\ \and X, Z, 222222222}
\date{}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Benutzerverwaltung}

Das Benutzerverwaltungsmodul übernimmt Authentifizierung, Autorisierung, Rollenverwaltung und Teamzuweisungen. Die folgenden Abschnitte beschreiben die Komponenten dieses Moduls im Detail.

\subsection{Überblick}

Das Benutzerverwaltungsmodul ist ein grundlegender Bestandteil der Anwendung und zuständig für Benutzer-Authentifizierung, Autorisierung, rollenbasierte Zugriffskontrolle und Teamzuweisungen. Es wird mit Flask als Web-Framework, Flask-Login für Sitzungsverwaltung, SQLAlchemy für objekt-relationales Mapping (ORM) und Jinja2 für dynamisches Template-Rendering implementiert.

\noindent Das System definiert zwei verschiedene Benutzerrollen:
\begin{itemize}
  \item \textbf{Admin/Coach:} Vollzugriff auf benutzerbezogene Operationen. Admins können Benutzerkonten erstellen, bearbeiten und löschen. Ein einzelnes Standardteam kann pro Anwendung über die Admin-Einstellungen ausgewählt werden, das automatisch allen Benutzern zugewiesen wird.
  \item \textbf{Benutzer/Player:} Eingeschränkter Zugriff. Normale Benutzer können sich anmelden und mit der Anwendung interagieren, dürfen aber nur ihr eigenes Passwort zurücksetzen.
\end{itemize}
\noindent Rollenbasierter Zugriff wird über Dekoratoren durchgesetzt. Alle geschützten Routen erfordern die Anmeldung mittels \texttt{@login\_required}, und Admin-Routen sind zusätzlich durch einen benutzerdefinierten \texttt{@admin\_required}-Dekorator eingeschränkt. Das Modul verwendet moderne Hashing-Algorithmen wie \texttt{scrypt} zur sicheren Passwortverarbeitung, sodass keine Passwörter im Klartext gespeichert werden.

\noindent Die Implementierung folgt einer modularen Struktur, die Routing-Logik, Geschäftslogik und Templates trennt, um Wartbarkeit und Erweiterbarkeit zu gewährleisten. So lassen sich Funktionen wie Zwei-Faktor-Authentifizierung, Benutzeraktivitätsverfolgung oder E-Mail-Verifikation zukünftig leicht ergänzen.

\subsection{Authentifizierung und Sitzungsverwaltung}

Die Klasse \texttt{UserController} verwaltet die Routen und die Integration mit Flask-Login. Im Konstruktor wird die Benutzerladefunktion mit Flask-Login verknüpft und die relevanten URLs für Login, Logout und Startseite registriert.\\

Die Methode \texttt{register\_routes} fügt folgende Routen hinzu:
\begin{itemize}
  \item \texttt{'/'}: die Startseite (nach dem Login),
  \item \texttt{'/login'}: akzeptiert GET und POST für Anzeige und Verarbeitung des Login-Formulars,
  \item \texttt{'/logout'}: meldet den Benutzer ab und löscht die Sitzung.
\end{itemize}

\noindent Durch die Bündelung der Routenregistrierung in einer Controller-Klasse bleibt der Code modular und übersichtlich.

\newpage
\noindent \textbf{Controller-Setup und Routenregistrierung:} \\
\begin{minted}{python}
class UserController:
    def __init__(self, app, login_mgr):
        self.app = app
        login_mgr.user_loader(self.load_user)
        self.register_routes()

    def register_routes(self):
        self.app.add_url_rule('/', view_func=self.index)
        self.app.add_url_rule('/login', view_func=self.login, methods=['GET', 'POST'])
        self.app.add_url_rule('/logout', view_func=self.logout)
\end{minted} 
\vspace{1em}
\noindent \textbf{Login-Logik:} \\

\noindent Die Methode \texttt{login()} verwaltet den Login-Vorgang. Zunächst wird die aktuelle Sitzung gelöscht. Ist der Benutzer bereits angemeldet, erfolgt eine Weiterleitung zur Hauptseite. Bei einem POST-Request werden die Anmeldedaten aus dem Formular geholt, der Benutzer gesucht und das Passwort überprüft. Bei Erfolg wird der Benutzer eingeloggt, andernfalls erscheint eine Fehlermeldung. Bei GET wird das Login-Formular angezeigt.

\begin{minted}{python}
@staticmethod
def login():
    session.clear()
    if current_user.is_authenticated:
        return redirect(url_for('game_options'))

    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        user = UserModel.query.filter_by(username=username).first()
        if user and check_password_hash(user.password, password):
            login_user(user)
            flash('Login erfolgreich!', 'success')
            return redirect(url_for('game_options'))
        flash('Ungültige Zugangsdaten', 'danger')

    return render_template('auth/login.html')
\end{minted}

\subsection{Benutzerverwaltung}

Dieser Abschnitt behandelt Admin-Funktionen zur Benutzerverwaltung wie Hinzufügen, Bearbeiten, Löschen und Passwortzurücksetzung. Neue Benutzer erhalten automatisch das aktuell ausgewählte Standardteam. Spieler können dieses Team nicht ändern, aber die verfügbaren Teams einsehen. Nur Admins haben Zugriff auf diese Funktionen. Normale Benutzer dürfen nur ihr eigenes Passwort ändern.

\subsection{Rollenbasierte Fähigkeiten}

Die folgende Tabelle fasst die Möglichkeiten je nach Rolle zusammen:

\begin{table}[h!]
\centering
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{|X|c|c|}
\hline
\textbf{Funktion} & \textbf{Admin} & \textbf{Benutzer} \\
\hline
Alle Benutzer anzeigen       & Ja & Nein \\
Benutzer hinzufügen/löschen  & Ja & Nein \\
Benutzerdaten bearbeiten     & Ja & Nein \\
Passwort anderer zurücksetzen & Ja & Nein \\
Eigenes Passwort ändern      & Ja & Ja \\
\hline
\end{tabularx}
\caption{Rechte-Matrix für Admin und Benutzer}
\end{table}

\noindent Diese Rechte werden mit \texttt{@login\_required} und dem benutzerdefinierten \texttt{@admin\_required}-Dekorator durchgesetzt.

\subsection*{Routen für Benutzeraktionen}

Alle benutzerbezogenen Routen sind in der Klasse \texttt{UserManagementController} organisiert. Jede Route übernimmt eine bestimmte Aktion wie Anzeige, Erstellung, Bearbeitung oder Löschung von Benutzern.

\begin{minted}{python}
class UserManagementController:
    def register_routes(self):
        self.app.add_url_rule('/users', view_func=self.user_list)
        self.app.add_url_rule('/users/add', view_func=self.add_user, methods=['GET', 'POST'])
        self.app.add_url_rule('/users/<int:id>/edit', view_func=self.edit_user, methods=['GET', 'POST'])
        self.app.add_url_rule('/users/<int:id>/delete', view_func=self.delete_user, methods=['POST'])
        self.app.add_url_rule('/users/<int:id>/reset-password', view_func=self.reset_password, methods=['GET', 'POST'])
\end{minted}

\subsection*{Benutzer hinzufügen}

Admins können neue Benutzer über \texttt{/users/add} hinzufügen. Bei GET wird das Formular angezeigt, bei POST werden die Daten verarbeitet:
\begin{itemize}
  \item Benutzername, Passwort und Rolle werden übernommen,
  \item es wird geprüft, ob der Benutzername existiert,
  \item das Passwort wird mit \texttt{scrypt} gehasht,
  \item ein neuer Benutzer wird gespeichert und weitergeleitet.
\end{itemize}

\begin{minted}{python}
@admin_required
def add_user(self):
    if request.method == 'POST':
        uname = request.form['username']
        pwd = request.form['password']
        role = request.form.get('role', 'user')

        if UserModel.query.filter_by(username=uname).first():
            flash('Benutzername existiert bereits', 'danger')
            return redirect(url_for('add_user'))

        hashed = generate_password_hash(pwd, method='scrypt')
        user = UserModel(username=uname, password=hashed, role=role)
        db.session.add(user)
        db.session.commit()
        flash('Benutzer hinzugefügt', 'success')
        return redirect(url_for('user_list'))

    return render_template('user/user_add.html')
\end{minted}

\subsection*{Benutzer bearbeiten}

Die Route \texttt{/users/<id>/edit} ermöglicht Admins das Ändern von Benutzernamen und Rollen. Die letzte Admin-Rolle im System darf dabei nicht entfernt werden.

\subsection*{Benutzer löschen}

Die Route \texttt{/users/<id>/delete} erlaubt das Löschen eines Benutzers über POST, um versehentliche Klicks zu vermeiden.

\subsection*{Passwörter zurücksetzen}

Admins können über \texttt{/users/<id>/reset-password} jedes Passwort ändern. Das Formular wird bei GET angezeigt und bei POST mit neuem Hash gespeichert.

\subsection*{Admin-Schutzprüfung}

Beim Bearbeiten wird sichergestellt, dass der letzte Admin nicht zur Rolle \texttt{user} geändert werden kann:

\begin{minted}{python}
if user.role == 'admin' and admin_count == 1 and new_role != 'admin':
    flash('Du bist der einzige Admin.', 'danger')
    return redirect(url_for('edit_user', user_id=user.id))
\end{minted}
\newpage
\subsection{Modellstruktur}

Die Klasse \texttt{UserModel} definiert die Benutzerdatenbankstruktur. Sie erweitert sowohl SQLAlchemy's \texttt{db.Model} als auch Flask-Login’s \texttt{UserMixin}.

\begin{itemize}
  \item \texttt{id}: Primärschlüssel.
  \item \texttt{username}: Eindeutiger Login-Name.
  \item \texttt{password}: Gehashter Passwort-String.
  \item \texttt{role}: Rolle des Benutzers, Standard ist \texttt{'user'}.
  \item \texttt{team\_id}: Fremdschlüssel zur Team-Tabelle.
  \item \texttt{team}: Verknüpfung zum \texttt{TeamModel}.
\end{itemize}

\begin{minted}{python}
class UserModel(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True) 
    username = db.Column(db.String(80), unique=True, nullable=False) 
    password = db.Column(db.String(120), nullable=False)  
    role = db.Column(db.String(10), default='user') 
    team_id = db.Column(db.Integer, db.ForeignKey('teams.id')) 
    team = db.relationship('TeamModel', backref='users') 
\end{minted}

\subsection{Passwortsicherheit}

Passwörter werden niemals im Klartext gespeichert, sondern mit dem Algorithmus \texttt{scrypt} sicher gehasht. 

\noindent \textbf{Beim Registrieren:}
\begin{minted}{python}
from werkzeug.security import generate_password_hash
hashed = generate_password_hash(password, method='scrypt')
\end{minted}

\noindent \textbf{Beim Login:}
\begin{minted}{python}
from werkzeug.security import check_password_hash
if check_password_hash(user.password, password):
    login_user(user)
\end{minted}

\noindent Dieser Mechanismus schützt Benutzerkonten auch bei einem Datenbank-Leak vor der Entschlüsselung durch Angreifer.


\newpage
\section{Team-Erstellung}

Das Modul zur Team-Erstellung bietet zwei flexible Methoden zur Erstellung eines neuen Teams mit Wappenschild: einen schrittweisen visuellen Builder und eine Direkt-Upload-Oberfläche. Beide Abläufe sind vollständig mit dem Backend und der Datenbank integriert und stellen ein konsistentes Team-Modell in der gesamten Anwendung sicher.

\subsection{Überblick}

Benutzer können Teams auf zwei Arten erstellen:
\begin{itemize}
    \item Über den \textbf{Individuellen Schild-Builder}, eine mehrstufige Oberfläche zur Konfiguration von Form, Muster, Farben und Symbol.
    \item Über den \textbf{Upload-Flow}, bei dem ein Benutzer ein transparentes PNG oder SVG hochlädt, und das System die Farben automatisch erkennt.
\end{itemize}

Das Endergebnis beider Abläufe ist ein generiertes SVG, das auf der Festplatte gespeichert wird, sowie ein neuer Eintrag in der Datenbank mit Metadaten zum Team.

\subsection{Erstellungs-Abläufe}

\subsubsection*{Ablauf 1: Individueller Schild-Builder}

Diese Methode führt den Benutzer durch 7 Schritte:

\begin{enumerate}
    \item \textbf{Form auswählen:} Auswahl einer Schildumrandung (SVG-Pfad).
    \item \textbf{Muster wählen:} Dekoratives Füllmuster aus sechs voreingestellten Typen auswählen.
    \item \textbf{Farben setzen:} Primär- und Sekundärfarbe mit Farbwählern wählen.
    \item \textbf{Muster anpassen:} Musterfüllung innerhalb der Form verschieben und skalieren.
    \item \textbf{Symbolauswahl:} Schildsymbol (SVG oder transparentes PNG) auswählen oder hochladen.
    \item \textbf{Symbol anpassen:} Symbol im Schild positionieren und skalieren.
    \item \textbf{Name & Absenden:} Teamnamen angeben und Formular absenden.
\end{enumerate}
\noindent Am Ende des Prozesses wird ein vollständiges SVG serialisiert und das Formular sendet alle Konfigurationsdaten an die POST-Route \texttt{/team/create}.

\begin{minted}{python}
@team_bp.route('/create', methods=['GET', 'POST'])
def create_team():
    ...
    if request.method == 'POST':
        name = request.form.get('name')
        primary_color = request.form.get('primary_color')
        secondary_color = request.form.get('secondary_color')
        icon_file = request.form.get('icon_filename')
        final_svg = request.form.get('final_svg')
        ...
        # Endgültige SVG-Datei speichern
        with open(svg_path, "w", encoding="utf-8") as f:
            f.write(final_svg)

        icon_path = url_for('static', filename=f'user_created_icons/{safe_name}/team_icon.svg')
        new_team = TeamModel(
            name=name,
            icon=icon_path,
            primary_color=primary_color,
            secondary_color=secondary_color
        )
        db.session.add(new_team)
        db.session.commit()
\end{minted}

\subsubsection*{Ablauf 2: Teambild-Upload (mit Farberkennung)}

Diese alternative Methode erlaubt es Benutzern, ein transparentes PNG oder SVG hochzuladen, anstatt den Schritt-für-Schritt-Builder zu verwenden. Sie ist über die Route \texttt{/upload\_icon} erreichbar und führt durch drei Schritte:

\begin{enumerate}
    \item \textbf{Bild hochladen:} Der Benutzer lädt eine SVG- oder transparente PNG-Datei hoch.
    \item \textbf{Automatische Farberkennung:} Das System analysiert das Bild und extrahiert zwei dominierende Farben.
    \item \textbf{Farben anpassen & benennen:} Die erkannten Farben werden vorausgefüllt und können vom Benutzer überschrieben werden, bevor abgesendet wird.
\end{enumerate}

\paragraph{Farberkennungs-Logik:}
Die Farberkennung erfolgt serverseitig mithilfe der \texttt{Pillow (PIL)}-Bibliothek. Nach dem Upload:

\begin{itemize}
    \item Das Bild wird in RGBA konvertiert und auf 64x64 Pixel verkleinert.
    \item Nur Pixel mit ausreichend Deckkraft (Alpha) werden berücksichtigt.
    \item RGB-Werte werden mit \texttt{collections.Counter} gezählt.
    \item Die zwei häufigsten RGB-Farben werden gewählt und ins Hex-Format konvertiert.
\end{itemize}

\begin{minted}{python}
def extract_dominant_colors(file_storage):
    img = Image.open(file_storage.stream).convert("RGBA")
    img = img.resize((64, 64))
    pixels = [pixel for pixel in img.getdata() if pixel[3] > 0]
    rgb_pixels = [(r, g, b) for r, g, b, _ in pixels]
    most_common = Counter(rgb_pixels).most_common(2)
    hex_colors = [f"#{r:02x}{g:02x}{b:02x}" for r, g, b in [c[0] for c in most_common]]
    ...
    return hex_colors[0], hex_colors[1]
\end{minted}

\paragraph{Fallback-Verhalten:}
Wenn das hochgeladene Bild:
\begin{itemize}
    \item \textbf{vollständig transparent} ist: werden \texttt{\#000000} und \texttt{\#ffffff} verwendet.
    \item \textbf{einfärbig} ist: wird die zweite Farbe standardmäßig auf \texttt{\#ffffff} gesetzt.
\end{itemize}

\paragraph{Frontend-Integration:}
Im Frontend wird eine Live-Vorschau im SVG-Element dargestellt. Benutzer können die automatisch erkannten Farben mit \texttt{iro.js} Farbwählern anpassen und anschließend das Team benennen. Das finale Design wird als vollständiges SVG serialisiert und über POST übertragen.

\paragraph{Endgültige Übertragung:}
Folgende Felder werden beim Absenden an den Server übergeben:

\begin{itemize}
    \item \texttt{name} : Teamname (auf Einzigartigkeit geprüft)
    \item \texttt{final\_svg} : generiertes Design
    \item \texttt{primary\_color}, \texttt{secondary\_color} : aus Farbwähler oder Erkennung
    \item \texttt{icon} : hochgeladene Datei
\end{itemize}

\noindent Diese Daten werden gespeichert und im \texttt{TeamModel} registriert – identisch zum Builder-Ablauf. Der Upload-Flow bietet eine schnelle und benutzerfreundliche Möglichkeit, individuelle Designs ohne Schritt-für-Schritt-Konfiguration zu integrieren.

\subsection{Team-Modell}

Das Schema \texttt{TeamModel} speichert Symbolpfad, Name und Farben jedes Teams. Diese Struktur unterstützt die Benutzerzuweisung und spätere teambezogene Logik.

\begin{minted}{python}
class TeamModel(db.Model):
    __tablename__ = 'teams'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False, unique=True)
    icon = db.Column(db.String(300), nullable=False)
    primary_color = db.Column(db.String(20), nullable=False)
    secondary_color = db.Column(db.String(20), nullable=False)
\end{minted}

\subsection{Teamauflistung und -löschung}

Admins können alle erstellten Teams und zugehörige Mitglieder unter \texttt{/team/list} einsehen. Für jedes Team werden angezeigt:

\begin{itemize}
    \item Teamname
    \item Farb-Badges für Primär- und Sekundärfarbe
    \item Zugeordnete Mitglieder
    \item Lösch-Button (nur für Admins, mit Bestätigung)
\end{itemize}

\noindent Wenn einem Team Benutzer zugewiesen sind, wird die Löschung blockiert und eine Flash-Nachricht angezeigt.

\begin{minted}{python}
@team_bp.route('/delete/<int:team_id>', methods=['POST'])
def delete_team(team_id):
    team = TeamModel.query.get_or_404(team_id)
    users_assigned = UserModel.query.filter_by(team_id=team_id).all()
    if users_assigned:
        flash('Team kann nicht gelöscht werden, solange Benutzer zugewiesen sind.', 'danger')
        return redirect(url_for('team.list_all_teams'))
    ...
    db.session.delete(team)
    db.session.commit()
\end{minted}

\subsection{Sicherheit und Validierung}

\begin{itemize}
    \item Teamnamen müssen eindeutig sein – Duplikate werden mit Flash-Meldung zurückgewiesen.
    \item Uploads werden mit \texttt{secure\_filename()} gesäubert, um Dateisystemprobleme zu vermeiden.
    \item Nur SVG- und PNG-Dateien sind für Icons erlaubt.
    \item Erforderliche Felder (Name, Farben, SVG) werden vor dem Speichern überprüft.
    \item Teams können nicht gelöscht werden, wenn ihnen noch Benutzer zugewiesen sind.
\end{itemize}

\noindent Diese Prüfungen garantieren Datenintegrität und verhindern versehentlichen Verlust oder Dateifehler.


\end{document}