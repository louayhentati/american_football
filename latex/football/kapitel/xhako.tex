\documentclass[12pt]{article}

% Language & Encoding
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

% Page Layout
\usepackage{geometry}
\geometry{a4paper, margin=2.5cm}
\usepackage{tabularx}

% Code Listings with Minted
\usepackage{minted}
\usemintedstyle{default}
\setminted{
    fontsize=\small,
    tabsize=2,
    breaklines=true
}

% Colored boxes around code
\usepackage{tcolorbox}
\usepackage{etoolbox}
\BeforeBeginEnvironment{minted}{\begin{tcolorbox}[colback=gray!5, colframe=gray!30, boxrule=0.5pt, arc=2pt]}
\AfterEndEnvironment{minted}{\end{tcolorbox}}

% Better Typography
\usepackage{microtype}

% Hyperlinks
\usepackage{hyperref}

\title{Documentation: User Management Module}
\author{X, Y, 999999999\\ \and X, Z, 222222222}
\date{}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{User Management}


The User Management module handles authentication, authorization, role management, and team assignments. The following sections describe the module's components in detail.

\subsection{Overview}

The User Management module is a foundational part of the application, responsible for user authentication, authorization, role-based access control, and team assignments. It is implemented using Flask as the web framework, Flask-Login for session management, SQLAlchemy for object-relational mapping (ORM), and Jinja2 for dynamic template rendering.

The system defines two distinct user roles:
\begin{itemize}
  \item \textbf{Admin/Coach:} Full access to user-related operations. Admins can create, edit, and delete user accounts. Each admin can select one default team, which is automatically assigned to new users they create.
  \item \textbf{User/Player:} Limited access. Regular users can log in and interact with the application but are restricted to resetting their own passwords.
\end{itemize}
\noindent Role-based access is enforced using decorators. All protected routes require login via the \texttt{@login\_required} decorator, and administrative routes are further restricted using a custom \texttt{@admin\_required} decorator. The module uses secure password handling with modern hashing algorithms (such as \texttt{scrypt}), ensuring that user credentials are not stored in plain text.

\noindent The implementation follows a modular structure that separates routing logic, business logic, and templates for maintainability and clarity. This design allows for easy expansion in the future, including features like two-factor authentication, user activity tracking, or email-based account verification.


\subsection{Authentication and Session Management}

The \texttt{UserController} class handles the setup of user-related routes and session integration. In the constructor, it links Flask-Login to a user-loading function and registers the relevant URLs for login, logout, and the homepage.\\

The \texttt{register\_routes} method adds Flask route definitions for:
\begin{itemize}
  \item \texttt{'/'}: the index view (landing page after login),
  \item \texttt{'/login'}: accepts both GET and POST requests to render and process the login form,
  \item \texttt{'/logout'}: logs the user out and clears the session.
\end{itemize}

\noindent By structuring route registration inside a controller class, the logic stays modular and easier to maintain.
\newpage

\noindent \textbf{Controller setup and route registration:} \\
\begin{minted}{python}
class UserController:
    def __init__(self, app, login_mgr):
        self.app = app
        login_mgr.user_loader(self.load_user)
        self.register_routes()

    def register_routes(self):
        self.app.add_url_rule('/', view_func=self.index)
        self.app.add_url_rule('/login', view_func=self.login, methods=['GET', 'POST'])
        self.app.add_url_rule('/logout', view_func=self.logout)
\end{minted} 
\vspace{1em}
\noindent \textbf{Login view logic:} \\

\noindent The \texttt{login()} method manages the user login process. First, it clears any active session. If the user is already authenticated, they are redirected to the main page. Otherwise, it checks whether the request method is \texttt{POST} and retrieves the submitted credentials. It searches for a matching user in the database and verifies the password using \texttt{check\_password\_hash}. If authentication is successful, the user is logged in and redirected. Otherwise, a flash message indicates invalid credentials. For a \texttt{GET} request, the login form is rendered. 

\begin{minted}{python}
@staticmethod
def login():
    session.clear()
    if current_user.is_authenticated:
        return redirect(url_for('game_options'))

    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        user = UserModel.query.filter_by(username=username).first()
        if user and check_password_hash(user.password, password):
            login_user(user)
            flash('Login successful!', 'success')
            return redirect(url_for('game_options'))
        flash('Invalid credentials', 'danger')

    return render_template('auth/login.html')
\end{minted}

\subsection{User Management}

This section covers the administrative features for managing users, ... including adding, editing, deleting, and resetting passwords. New users are automatically assigned to the admin’s selected team.
These actions are strictly restricted to users with the \texttt{admin} role, while regular users can only reset their own password.

\subsection{Role-Based Capabilities}

The following table summarizes the actions available to each role:

\begin{table}[h!]
\centering
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{|X|c|c|}
\hline
\textbf{Capability} & \textbf{Admin} & \textbf{User} \\
\hline
View all users            & Yes & No \\
Add/Delete users             & Yes & No \\
Edit user data            & Yes & No \\
Reset any user's password & Yes & No \\
Reset own password        & Yes & Yes \\
\hline
\end{tabularx}
\caption{Permission matrix comparing Admin and User roles}
\end{table}

\noindent These capabilities are enforced using Flask-Login's \texttt{@login\_required} decorator for authentication and a custom \texttt{@admin\_required} decorator for admin-only access.

\subsection*{Routes for User Operations}

All user-related routes are registered within the \texttt{UserManagementController} class to keep the code modular and organized. Each route corresponds to a specific function such as listing users, creating a user, editing details, deleting entries, or assigning teams.

\begin{minted}{python}
class UserManagementController:
    def register_routes(self):
        self.app.add_url_rule('/users', view_func=self.user_list)
        self.app.add_url_rule('/users/add', view_func=self.add_user, methods=['GET', 'POST'])
        self.app.add_url_rule('/users/<int:id>/edit', view_func=self.edit_user, methods=['GET', 'POST'])
        self.app.add_url_rule('/users/<int:id>/delete', view_func=self.delete_user, methods=['POST'])
        self.app.add_url_rule('/users/<int:id>/reset-password', view_func=self.reset_password, methods=['GET', 'POST'])
\end{minted}

\subsection*{Adding a User}

Admins can add new users through a form rendered by the route \texttt{/users/add}. On a GET request, the route renders the form. On a POST request, it:
\begin{itemize}
  \item Retrieves username, password, and optional role from the form.
  \item Checks whether the username already exists.
  \item Hashes the password using the \texttt{scrypt} algorithm.
  \item Creates and saves a new user to the database.
  \item Redirects back to the user list on success.
\end{itemize}

\noindent This route is protected by the \texttt{@admin\_required} decorator to ensure only admins can access it.

\begin{minted}{python}
@admin_required
def add_user(self):
    if request.method == 'POST':
        uname = request.form['username']
        pwd = request.form['password']
        role = request.form.get('role', 'user')

        if UserModel.query.filter_by(username=uname).first():
            flash('Username exists', 'danger')
            return redirect(url_for('add_user'))

        hashed = generate_password_hash(pwd, method='scrypt')
        user = UserModel(username=uname, password=hashed, role=role)
        db.session.add(user)
        db.session.commit()
        flash('User added', 'success')
        return redirect(url_for('user_list'))

    return render_template('user/user_add.html')
\end{minted}

\subsection*{Editing a User}

The \texttt{/users/<id>/edit} route lets an admin update a user’s username or role. It displays a form on GET and updates the database on POST. A check is performed to ensure that the last remaining admin cannot demote themselves to a regular user, preserving admin access in the system.

\subsection*{Deleting a User}

The \texttt{/users/<id>/delete} route allows admins to remove a user. It requires a POST request to prevent accidental deletions through simple link clicks.

\subsection*{Resetting Passwords}

The \texttt{/users/<id>/reset-password} route allows admins to change any user's password securely. A form is shown on GET, and the new password is saved after hashing on POST.

\subsection*{Admin Protection Check}

To prevent removing all administrative access, a special condition is enforced during editing: if the user being modified is the only remaining admin, their role cannot be changed to \texttt{user}.

\begin{minted}{python}
if user.role == 'admin' and admin_count == 1 and new_role != 'admin':
    flash('You are the only admin.', 'danger')
    return redirect(url_for('edit_user', user_id=user.id))
\end{minted}


\subsection{Model Structure}

The \texttt{UserModel} class defines the schema for the application's users. It extends both SQLAlchemy’s \texttt{db.Model} and Flask-Login’s \texttt{UserMixin} to integrate seamlessly with session management and database ORM functionality.

Each user has a unique username, a securely hashed password, a role (either \texttt{admin} or \texttt{user}), and an optional assignment to a team.

\textbf{Explanation of fields:}
\begin{itemize}
  \item \texttt{id}: Primary key. A unique integer identifier for each user.
  \item \texttt{username}: A unique string identifier used for login. Cannot be null.
  \item \texttt{password}: Stores the hashed password string. Always required.
  \item \texttt{role}: Specifies the user's role in the system. Defaults to \texttt{'user'}.
  \item \texttt{team\_id}: A foreign key that references the associated team’s ID.
  \item \texttt{team}: A relationship object linking the user to a \texttt{TeamModel}.
\end{itemize}

\noindent Using SQLAlchemy’s relationship and foreign key system allows each user to optionally belong to a team, enabling role-based and group-based functionality later in the application.

\begin{minted}{python}
class UserModel(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True) 
    username = db.Column(db.String(80), unique=True, nullable=False) 
    password = db.Column(db.String(120), nullable=False)  
    role = db.Column(db.String(10), default='user') 
    team_id = db.Column(db.Integer, db.ForeignKey('teams.id')) 
    team = db.relationship('TeamModel', backref='users') 
\end{minted}

\noindent This model provides the core structure for user identity, authentication, and permission control. The role field is used to differentiate between standard users and administrators, while the team association enables team-specific logic such as filtering users or grouping data.


\subsection{Password Security}

To ensure the security and privacy of user credentials, passwords are never stored in plain text. Instead, they are securely hashed using the \texttt{scrypt} algorithm, which is a modern and memory-intensive hashing function designed to resist brute-force and dictionary attacks.

\noindent The application uses the \texttt{generate\_password\_hash} and \texttt{check\_password\_hash} functions from the \texttt{werkzeug.security} module to handle password hashing and verification.

\subsection*{How password hashing works}

When a user account is created or a password is updated, the plaintext password is passed to \texttt{generate\_password\_hash()}, which:
\begin{itemize}
  \item Applies the \texttt{scrypt} hashing algorithm.
  \item Generates a secure hash that includes a salt (random data added to the input).
  \item Returns a string containing the algorithm name, salt, and hashed output—all embedded together.
\end{itemize}

\noindent This hash is stored in the database in the \texttt{password} column of the \texttt{UserModel}. Importantly, the original password is discarded and never saved or accessible. \\

\noindent \textbf{Password hashing during registration:}
\begin{minted}{python}
from werkzeug.security import generate_password_hash
hashed = generate_password_hash(password, method='scrypt')
\end{minted}

\subsection*{How password verification works}

When a user attempts to log in, the application:
\begin{itemize}
  \item Retrieves the hash stored in the database for the submitted username.
  \item Uses \texttt{check\_password\_hash()} to compare the stored hash with the entered password.
  \item The function internally re-hashes the entered password using the salt stored in the original hash.
  \item If the resulting hash matches the stored one, the password is correct and the user is authenticated.
\end{itemize}

\noindent \textbf{Password verification during login:}
\begin{minted}{python}
from werkzeug.security import check_password_hash
if check_password_hash(user.password, password):
    login_user(user)
\end{minted}

This system ensures that even if the database were compromised, the passwords would not be exposed in a usable form. The use of \texttt{scrypt} makes brute-force attacks significantly more difficult compared to older algorithms like MD5 or SHA1.

\section{Team Creation}

The Team Creation module provides two flexible methods for generating a new team and shield icon: a step-by-step visual builder, and a direct upload interface. Both flows are fully integrated with the backend and database, ensuring a consistent team model across the application.

\subsection{Overview}

Users can create teams by either:
\begin{itemize}
    \item Using the \textbf{Custom Shield Builder}, a multi-step interface allowing shape, pattern, color, and icon configuration.
    \item Using the \textbf{Upload Flow}, where a user provides a transparent PNG or SVG icon and the system auto-detects colors.
\end{itemize}

The final output of either flow is a generated SVG saved on disk, along with a new entry in the database containing team metadata.

\subsection{Creation Flows}

\subsubsection*{Flow 1: Custom Shield Builder}

This method guides users through 7 steps:

\begin{enumerate}
    \item \textbf{Select Shape:} Choose a shield outline (SVG path).
    \item \textbf{Choose Pattern:} Apply a decorative fill from six preset pattern types.
    \item \textbf{Set Colors:} Pick primary and secondary colors using color pickers.
    \item \textbf{Adjust Pattern:} Drag and scale the pattern fill within the shape.
    \item \textbf{Icon Selection:} Choose or upload a shield icon (SVG or transparent PNG).
    \item \textbf{Icon Adjustment:} Position and zoom the icon within the shield.
    \item \textbf{Naming and Submission:} Provide a team name and submit.
\end{enumerate}

\noindent At the end of this process, a complete SVG is serialized, and the form sends all configuration data to the \texttt{/team/create} POST route.
\begin{minted}{python}
@team_bp.route('/create', methods=['GET', 'POST'])
def create_team():
    ...
    if request.method == 'POST':
        name = request.form.get('name')
        primary_color = request.form.get('primary_color')
        secondary_color = request.form.get('secondary_color')
        icon_file = request.form.get('icon_filename')
        final_svg = request.form.get('final_svg')
        ...
        # Save final SVG file
        with open(svg_path, "w", encoding="utf-8") as f:
            f.write(final_svg)

        icon_path = url_for('static', filename=f'user_created_icons/{safe_name}/team_icon.svg')
        new_team = TeamModel(
            name=name,
            icon=icon_path,
            primary_color=primary_color,
            secondary_color=secondary_color
        )
        db.session.add(new_team)
        db.session.commit()
\end{minted}

\subsubsection*{Flow 2: Upload Team Icon (with Color Detection)}

This alternative creation method allows users to directly upload a transparent PNG or SVG icon instead of customizing a shield step-by-step. It is accessed via the route \texttt{/upload\_icon} and presents a guided 3-step form:

\begin{enumerate}
    \item \textbf{Upload Image:} The user provides an SVG or transparent PNG file.
    \item \textbf{Auto Color Detection:} The system automatically analyzes the image and extracts two dominant colors.
    \item \textbf{Adjust Colors and Name:} The detected colors are pre-filled in color pickers, which the user can override before submitting.
\end{enumerate}

\paragraph{Color Detection Logic:}
Color extraction is performed server-side using the \texttt{Pillow (PIL)} library. After image upload:

\begin{itemize}
    \item The image is converted to RGBA and resized to 64x64 pixels.
    \item Only pixels with alpha (transparency) above a threshold are considered.
    \item RGB tuples are counted using \texttt{collections.Counter}.
    \item The two most frequent RGB values are selected and converted to hex format.
\end{itemize}

\begin{minted}{python}
def extract_dominant_colors(file_storage):
    img = Image.open(file_storage.stream).convert("RGBA")
    img = img.resize((64, 64))
    pixels = [pixel for pixel in img.getdata() if pixel[3] > 0]
    rgb_pixels = [(r, g, b) for r, g, b, _ in pixels]
    most_common = Counter(rgb_pixels).most_common(2)
    hex_colors = [f"#{r:02x}{g:02x}{b:02x}" for r, g, b in [c[0] for c in most_common]]
    ...
    return hex_colors[0], hex_colors[1]
\end{minted}

\paragraph{Fallback Handling:}
If the uploaded image is:
\begin{itemize}
    \item \textbf{Completely transparent}: fallback colors \texttt{\#000000} and \texttt{\#ffffff} are used.
    \item \textbf{Monochromatic}: the second color defaults to \texttt{\#ffffff}.
\end{itemize}

\paragraph{Frontend Integration:}
On the frontend, a live preview is rendered inside an SVG element. Users can review the shape, manually adjust the detected colors using embedded color pickers (via \texttt{iro.js}), and then name the team. The final design, including the auto-colored background and icon, is serialized into a full SVG and submitted as part of the POST request.

\paragraph{Final Submission:}
On submission, the following fields are sent to the server:

\begin{itemize}
    \item \texttt{name} : team name (validated for uniqueness)
    \item \texttt{final\_svg} : generated icon and background design
    \item \texttt{primary\_color}, \texttt{secondary\_color} : from color picker or detection
    \item \texttt{icon} : the uploaded file
\end{itemize}


\noindent This data is saved to disk and registered in the \texttt{TeamModel}, identical to the builder flow. The UI flow provides a fast and user-friendly method to integrate custom designs without requiring step-by-step customization.



\subsection{Team Model}

The \texttt{TeamModel} schema stores each team’s icon path, name, and colors. This structure supports user assignment and future team-specific logic.

\begin{minted}{python}
class TeamModel(db.Model):
    __tablename__ = 'teams'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False, unique=True)
    icon = db.Column(db.String(300), nullable=False)
    primary_color = db.Column(db.String(20), nullable=False)
    secondary_color = db.Column(db.String(20), nullable=False)
\end{minted}

\subsection{Team Listing and Deletion}

Admins can view all created teams and their members at \texttt{/team/list}. Each team entry shows:

\begin{itemize}
    \item Team name
    \item Primary and secondary color badges
    \item Members assigned to the team
    \item A delete button (admin-only, modal-confirmed)
\end{itemize}

\noindent If a team has users assigned, deletion is blocked with a flash message.

\begin{minted}{python}
@team_bp.route('/delete/<int:team_id>', methods=['POST'])
def delete_team(team_id):
    team = TeamModel.query.get_or_404(team_id)
    users_assigned = UserModel.query.filter_by(team_id=team_id).all()
    if users_assigned:
        flash('Cannot delete team while users are assigned.', 'danger')
        return redirect(url_for('team.list_all_teams'))
    ...
    db.session.delete(team)
    db.session.commit()
\end{minted}

\subsection{Security and Validation}

\begin{itemize}
    \item Team names must be unique and the duplicates are rejected with a flash message.
    \item Uploads are sanitized using \texttt{secure\_filename()} to avoid filesystem vulnerabilities.
    \item Only SVG and PNG files are accepted for icons.
    \item Required fields (name, colors, final SVG) are enforced before saving.
    \item Teams cannot be deleted if any users are still assigned.
\end{itemize}

\noindent These checks ensure data integrity and prevent unintended loss of access or file errors.

\subsection{Conclusion}

The Team Creation module offers a robust interface for creating visually customized teams. Its flexible builder, SVG serialization, color handling, and integration with SQLAlchemy ensure a professional experience for both users and admins. The modularity of the backend logic makes it easy to extend (e.g., adding team categories, preview exports, or in-app editing).



\end{document}
