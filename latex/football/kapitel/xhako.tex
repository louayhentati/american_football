\documentclass[12pt]{article}

% Sprache & Kodierung
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

% Seitenlayout
\usepackage{geometry}
\geometry{a4paper, margin=2.5cm}
\usepackage{tabularx}

% Code Listings mit Minted
\usepackage{minted}
\usemintedstyle{default}
\setminted{
    fontsize=\small,
    tabsize=2,
    breaklines=true
}

% Farbige Boxen um Code
\usepackage{tcolorbox}
\usepackage{etoolbox}
\BeforeBeginEnvironment{minted}{\begin{tcolorbox}[colback=gray!5, colframe=gray!30, boxrule=0.5pt, arc=2pt]}
\AfterEndEnvironment{minted}{\end{tcolorbox}}

% Bessere Typografie
\usepackage{microtype}

% Hyperlinks
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue
}

\title{Dokumentation: Benutzerverwaltungssystem}
\author{Leo}
\date{}

\begin{document}

\maketitle

\section{User Management}

\subsection{Modulübersicht}

Das Benutzerverwaltungssystem ist in zwei zentrale Controller-Klassen unterteilt, die jeweils unterschiedliche Verantwortlichkeiten übernehmen, jedoch eng miteinander verzahnt sind. Ziel ist es, eine sichere, rollenbasierte und intuitive Benutzerverwaltung in einer Flask-Webanwendung zu realisieren.

\begin{itemize}
  \item \textbf{UserController}: Zuständig für Authentifizierungsprozesse wie Login, Logout sowie die Verwaltung der aktuellen Benutzersitzung. Er prüft Anmeldedaten, authentifiziert Benutzer, leitet je nach Authentifizierungsstatus weiter und sorgt für eine sichere Abmeldung inklusive Sitzungsbereinigung.
  
  \item \textbf{UserManagementController}: Dieser Controller verwaltet den Lebenszyklus eines Benutzers im System. Er erlaubt das Anlegen, Bearbeiten, Löschen und Zurücksetzen von Benutzerkonten. Zusätzlich stellt er sicher, dass nur Administratoren Zugriff auf kritische Funktionen erhalten, etwa das Bearbeiten anderer Benutzerkonten oder das Ändern von Rollen.
\end{itemize}

\noindent Diese beiden Controller greifen auf ein zentrales Benutzermodell zurück und arbeiten über klar definierte Routen mit der Benutzeroberfläche (HTML-Templates) zusammen. Die Authentifizierung erfolgt mit \texttt{Flask-Login}, während Passwortsicherheit über \texttt{Werkzeug}'s \texttt{generate\_password\_hash()} und \texttt{check\_password\_hash()} gewährleistet wird.

\subsubsection*{Initiale Routenregistrierung}

Sowohl \texttt{UserController} als auch \texttt{UserManagementController} registrieren ihre Routen beim Start automatisch, um die Lesbarkeit im Hauptprogramm zu erhöhen:

\begin{minted}{python}
self.app.add_url_rule('/login', view_func=self.login, methods=['GET', 'POST'])
self.app.add_url_rule('/logout', view_func=self.logout)
self.app.add_url_rule('/users/<int:user_id>/edit', view_func=self.edit_user, methods=['GET', 'POST'])
\end{minted}

\newpage
\subsubsection*{Benutzerzustand und automatische Weiterleitungen}

Der \texttt{UserController} stellt sicher, dass authentifizierte Benutzer direkt zur Hauptanwendung (\texttt{game\_options}) weitergeleitet werden, während nicht angemeldete Benutzer das Login-Formular sehen:

\begin{minted}{python}
@staticmethod
def index():
    if current_user.is_authenticated:
        return redirect(url_for('game_options'))
    return render_template('auth/login.html')
\end{minted}

\noindent Dadurch wird ein nahtloses und sicheres Einstiegserlebnis gewährleistet, ohne dass der Benutzer unnötige Seiten aufrufen muss.

\subsubsection*{Trennung der Verantwortlichkeiten}

Die Trennung der Verantwortlichkeiten erlaubt es, Authentifizierungslogik (Session Handling, Redirects) vom eigentlichen Benutzer-Management (CRUD-Operationen, Rollenprüfung) sauber zu trennen. Diese modulare Architektur macht das System leicht wartbar und testbar. Änderungen an z.B. der Authentifizierung müssen nicht den Code zur Benutzerbearbeitung beeinflussen.

\subsubsection*{Rollenkontrolle mittels Decorator}

Für sicherheitskritische Funktionen innerhalb des \texttt{UserManagementController} wird ein zusätzlicher Decorator \texttt{@admin\_required} verwendet, der prüft, ob der aufrufende Benutzer die Administratorrolle besitzt:

\begin{minted}{python}
def admin_required(func):
    @wraps(func)
    def decorated_view(*args, **kwargs):
        if not current_user.is_authenticated or current_user.role != 'admin':
            abort(403)
        return func(*args, **kwargs)
    return decorated_view
\end{minted}

\noindent Damit wird sichergestellt, dass normale Benutzer nicht auf geschützte Funktionen wie das Bearbeiten oder Löschen anderer Benutzer zugreifen können.

\subsubsection*{Zentrale Sitzungsverwaltung und Fehlerbehandlung}

Im gesamten Modul wird auf zentrale Sitzungsverwaltung (mittels \verb|session.clear()|) und strukturierte Fehlerbehandlung (z.B. \verb|abort(403)| bei unberechtigtem Zugriff) geachtet.


\subsection{Authentifizierung}

Die Authentifizierung im System erfolgt durch das \texttt{Flask-Login}-Framework, welches eine einfache Benutzerverwaltung und Sitzungssteuerung für Flask-Anwendungen ermöglicht. Benutzer werden anhand ihres Benutzernamens und des verschlüsselten Passworts überprüft und erhalten bei erfolgreicher Anmeldung Zugriff auf geschützte Bereiche der Anwendung.

\subsubsection*{Login-Prozess}

Beim Aufruf der Login-Seite wird überprüft, ob der Benutzer bereits angemeldet ist. Falls ja, wird er direkt zur Hauptseite der Anwendung weitergeleitet:

\begin{minted}{python}
if current_user.is_authenticated:
    return redirect(url_for('game_options'))
\end{minted}

\noindent Ist der Benutzer nicht angemeldet, wird das Login-Formular angezeigt. Beim Absenden des Formulars werden die eingegebenen Zugangsdaten überprüft:


\begin{minted}{python}
username = request.form.get('username')
password = request.form.get('password')
user = UserModel.query.filter_by(username=username).first()

if user and check_password_hash(user.password, password):
    login_user(user)
    flash('Login successful!', 'success')
    return redirect(url_for('game_options'))
\end{minted}

\noindent Dabei wird das eingegebene Passwort mit dem in der Datenbank gespeicherten, gehashten Passwort mithilfe der Funktion \texttt{check\_password\_hash()} verglichen. Nur bei einem positiven Abgleich wird der Benutzer authentifiziert und die Sitzung wird durch \texttt{login\_user(user)} gestartet. Erfolgt keine Übereinstimmung, wird eine Fehlermeldung angezeigt.

\subsubsection*{Sitzung und Benutzerstatus}

Nach erfolgreicher Authentifizierung steht der Benutzer über die Variable \texttt{current\_user} global im gesamten System zur Verfügung. Diese wird durch \texttt{Flask-Login} automatisch befüllt, sobald eine gültige Sitzung erkannt wird.

\noindent Der \texttt{UserController} registriert außerdem die benötigte \texttt{user\_loader}-Funktion zur Wiederherstellung des Benutzers aus der Session:


\begin{minted}{python}
@login_manager.user_loader
def load_user(user_id):
    return UserModel.query.get(int(user_id))
\end{minted}

\noindent Diese Funktion erlaubt es, den Benutzer anhand seiner gespeicherten ID aus der Datenbank zu laden und die Session bei jedem Request korrekt zu verknüpfen.
\newpage
\subsubsection*{Logout-Prozess}

Beim Abmelden wird die aktuelle Sitzung gelöscht, der Benutzer aus dem Session-Kontext entfernt und zur Login-Seite zurückgeleitet:

\noindent
\begin{minted}{python}
logout_user()
flash('who are you ?', 'success')
session.clear()
return redirect(url_for('login'))
\end{minted}

\noindent Die zusätzliche Verwendung von \texttt{session.clear()} stellt sicher, dass keine Rückstände in der Session verbleiben, die nachträglich ausgenutzt werden könnten. Ein Flash-Message-Hinweis gibt dem Benutzer eine visuelle Bestätigung über die erfolgreiche Abmeldung.

\subsubsection*{Zugriffsschutz durch \texttt{@login\_required}}

Alle Funktionen im System, die nur von angemeldeten Benutzern aufgerufen werden dürfen, sind mit dem Decorator \texttt{@login\_required} versehen:

\noindent
\begin{minted}{python}
@login_required
def user_list(self):
    users = UserModel.query.all()
    return render_template('user/user_list.html', users=users)
\end{minted}

\noindent Durch diesen Mechanismus wird sichergestellt, dass anonyme Benutzer keine geschützten Seiten aufrufen können. Beim Versuch eines unautorisierten Zugriffs wird automatisch auf die Login-Seite umgeleitet.

\subsection{Rollenbasierte Fähigkeiten}

Das System unterscheidet zwei Rollen für Benutzerkonten: \texttt{user} und \texttt{admin}. Diese Rollen definieren, welche Funktionen einem Benutzer innerhalb der Anwendung zur Verfügung stehen, und bilden die Grundlage für die Zugriffskontrolle auf Systemebene.

\subsubsection*{Administratorrechte}

Benutzer mit der Rolle \texttt{admin} haben vollständigen Zugriff auf alle Verwaltungsfunktionen der Anwendung. Sie dürfen neue Benutzer anlegen, bestehende Benutzer bearbeiten oder löschen, Rollen ändern und Passwörter anderer Benutzer zurücksetzen. Darüber hinaus haben sie Zugriff auf spezielle Seiten zur Benutzerübersicht und können damit die Struktur der Benutzerbasis kontrollieren und anpassen.

\subsubsection*{Rechte normaler Benutzer}

Normale Benutzer mit der Rolle \texttt{user} haben eingeschränkten Zugriff. Sie können die Benutzerliste einsehen, um Informationen zu anderen registrierten Benutzern zu erhalten. Darüber hinaus dürfen sie ihr eigenes Passwort ändern. Andere Funktionen wie das Bearbeiten oder Löschen von Benutzern, das Zuweisen von Rollen oder das Ändern des eigenen Benutzernamens stehen ihnen nicht zur Verfügung.

\subsubsection*{Technische Umsetzung der Zugriffskontrolle}

Zur Durchsetzung der rollenbasierten Einschränkungen wird serverseitig geprüft, ob der aktuell angemeldete Benutzer über ausreichende Rechte verfügt. Dies geschieht über gezielte Rollenabfragen in den Controllern. Bei unberechtigtem Zugriff wird der Zugriff verweigert und eine Fehlermeldung angezeigt. In der Benutzeroberfläche werden bestimmte Aktionen und Schaltflächen zusätzlich dynamisch ausgeblendet, um eine intuitive Benutzererfahrung zu gewährleisten.

\noindent Ein Beispiel für eine typische Rechteprüfung ist die Absicherung sensibler Funktionen durch eine explizite Abfrage der Rolle. Nur wenn die Rolle des angemeldeten Benutzers als „admin“ erkannt wird, darf die entsprechende Aktion ausgeführt werden.

\subsection{Benutzerverwaltung}

Die Benutzerverwaltung ist ein zentraler Bestandteil des Systems und ermöglicht es Administratoren, Benutzerkonten effizient zu steuern. Dies umfasst das Erstellen, Bearbeiten, Löschen sowie das Zurücksetzen von Passwörtern. Die Implementierung erfolgt im \texttt{UserManagementController}, der über eigene Routen in der Webanwendung eingebunden ist.

\subsubsection*{Benutzer anlegen}

Administratoren können neue Benutzer über ein Formular hinzufügen. Dabei werden Benutzername, Passwort und Rolle übermittelt. Das Passwort wird nicht im Klartext gespeichert, sondern sofort mittels \texttt{scrypt} gehasht, bevor es in die Datenbank geschrieben wird. Vor dem Speichern erfolgt außerdem eine Prüfung auf Eindeutigkeit des Benutzernamens.

\subsubsection*{Benutzer bearbeiten}

Bei der Bearbeitung von Benutzern können Administratoren den Benutzernamen und die Rolle eines bestehenden Benutzers anpassen. Zusätzlich wird verhindert, dass der letzte verbleibende Administrator seine eigenen Adminrechte verliert, um einen ungewollten Kontrollverlust über das System zu vermeiden.

\subsubsection*{Benutzer löschen}

Benutzerkonten können vollständig entfernt werden. Der Vorgang ist dauerhaft und löscht den Benutzer aus der Datenbank. Vor dem Löschen wird überprüft, ob der Benutzer existiert. Weitere Einschränkungen bezüglich der Löschberechtigung erfolgen durch die Rollenlogik im System, die separat behandelt wird.

\subsubsection*{Passwort zurücksetzen}

Eine zusätzliche Funktion erlaubt es, das Passwort eines Benutzers zurückzusetzen. Diese Aktion steht Administratoren zur Verfügung, aber auch normale Benutzer können ihr eigenes Passwort über eine separate Ansicht aktualisieren. Das neue Passwort wird ebenfalls gehasht in der Datenbank gespeichert.


\subsection{Passwortsicherheit}

Ein zentrales Element der Benutzersicherheit ist der vertrauliche und manipulationssichere Umgang mit Passwörtern. Im vorliegenden System werden Passwörter niemals im Klartext gespeichert oder übertragen. Stattdessen kommt eine sichere Hashfunktion zur Anwendung, um die Passwörter vor unbefugtem Zugriff zu schützen.

\noindent Beim Erstellen oder Zurücksetzen eines Benutzerkontos wird das eingegebene Passwort durch die Funktion \texttt{generate\_password\_hash()} aus dem Flask-Werkzeug-Modul in einen nicht umkehrbaren Hashwert umgewandelt. Dabei wird bewusst der moderne Algorithmus \texttt{scrypt} verwendet, der sich durch besondere Widerstandsfähigkeit gegen Brute-Force- und Hardware-basierte Angriffe auszeichnet.


\begin{minted}{python}
hashed_password = generate_password_hash(password, method='scrypt')
\end{minted}

\noindent Dieser Hashwert wird anschließend in der Datenbank gespeichert und dient beim Login als Referenz für den Passwortvergleich. Wenn sich ein Benutzer anmeldet, wird das eingegebene Passwort nicht direkt mit dem gespeicherten Hash verglichen. Stattdessen wird geprüft, ob das eingegebene Passwort den gleichen Hash ergibt. Dies geschieht über die Funktion \texttt{check\_password\_hash()}.

\noindent Ein typischer Ablauf beim Anlegen eines neuen Benutzers sieht dabei wie folgt aus:

\begin{minted}{python}
user = UserModel(username=username, password=hashed_password, role=role)
db.session.add(user)
db.session.commit()
\end{minted}

\noindent In dieser Struktur wird das bereits gehashte Passwort dem neuen Benutzerobjekt zugewiesen, bevor es dauerhaft in der Datenbank gespeichert wird.

\noindent Da weder beim Speichern noch beim Prüfen Klartext-Passwörter verarbeitet werden, wird ein hohes Maß an Sicherheit gewährleistet. Selbst im Falle eines Datenbanklecks wären die Passwörter durch die Einweg-Hashfunktion geschützt und nicht direkt rekonstruierbar.

\noindent Darüber hinaus erfolgt jeder Passwortwechsel sofort in verschlüsselter Form. Benutzer können ihr Passwort nur über ein sicheres Formular ändern, das durch Zugriffslogik geschützt ist. Eine Änderung des Passworts durch Dritte ist nur Administratoren vorbehalten. Diese Maßnahmen stellen sicher, dass sowohl bei der Anmeldung als auch im laufenden Betrieb keine sicherheitsrelevanten Schwachstellen im Umgang mit Passwörtern bestehen.


\section{Team Creation}

\subsection{Modulübersicht}


Das Modul „Team Creation“ erlaubt es Administratoren, individuelle Teams mit eigenem Wappen (Shield) anzulegen. Die Erstellung erfolgt wahlweise über einen visuellen Schritt-für-Schritt-Baukasten oder durch direkten Upload eines eigenen Logos. Beide Wege führen zu einem einheitlichen Datensatz mit Name, Farben und SVG-Grafik. Der Zugang zu diesem Modul ist ausschließlich Benutzern mit Administratorrechten vorbehalten.

\newpage
\subsubsection*{Funktionsüberblick}

\begin{itemize}
  \item Zwei Wege zur Teamerstellung:
  \begin{itemize}
    \item Schrittweise Gestaltung per Baukasten (Form, Muster, Farbe, Icon)
    \item Direkter Upload eines eigenen Icons (PNG oder SVG)
  \end{itemize}
  \item Automatische Extraktion der dominanten Farben bei Upload
  \item Live-Vorschau der entstehenden SVG
  \item Serverseitige Speicherung von SVG-Datei und optionalem Icon
  \item Einfache Erweiterbarkeit durch neue Icons oder Formen
\end{itemize}

\subsection{Modell: TeamModel}

Das zugrundeliegende Datenmodell für Teams wird durch die Klasse \texttt{TeamModel} dargestellt. Es definiert die Struktur der Team-Datenbanktabelle und enthält alle relevanten Informationen, die zur Darstellung und Verwaltung eines Teams notwendig sind – darunter Teamname, Farbwerte und das erzeugte SVG-Icon. Die folgende Definition zeigt die genaue Modellstruktur:

\begin{minted}{python}
class TeamModel(db.Model):
    __tablename__ = 'teams'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False, unique=True)
    icon = db.Column(db.String(300), nullable=False)
    primary_color = db.Column(db.String(20), nullable=False)
    secondary_color = db.Column(db.String(20), nullable=False)
\end{minted}

\noindent Jeder Eintrag enthält Name, zwei Farben und den Pfad zur erzeugten SVG-Grafik. Der Pfad verweist auf eine Datei im Ordner \texttt{/static/user\_created\_icons/<Teamname>/team\_icon.svg}.

\subsection{Routenübersicht}

Das Teammodul stellt mehrere HTTP-Routen zur Verfügung, über die die Erstellung, Anzeige und Verwaltung von Teams gesteuert wird. Jede Route übernimmt eine spezifische Aufgabe im Gesamtprozess und ist entsprechend abgesichert, sodass nur autorisierte Benutzer (z.B. Administratoren) auf kritische Funktionen wie das Löschen oder Anlegen von Teams zugreifen können:

\begin{itemize}
  \item \textbf{\texttt{/team/choice}} – Auswahlseite: Nutzer entscheidet sich zwischen Builder oder Upload
  \item \textbf{\texttt{/team/create}} – Startseite des Schritt-für-Schritt-Builders
  \item \textbf{\texttt{/team/upload\_icon}} – Upload-Seite für eigenes Logo
  \item \textbf{\texttt{/team/list}} – Zeigt alle existierenden Teams
  \item \textbf{\texttt{/team/delete/<id>}} – Löscht ein Team (nach Validierung)
\end{itemize}


\subsection{Team-Erstellung: Zwei Wege}

Nur Administratoren haben Zugriff auf die Team-Erstellungsfunktionalität. Sie können neue Teams auf zwei unterschiedliche Arten anlegen: entweder über einen grafischen Wappen-Baukasten (Shield Builder) oder durch den direkten Upload eines eigenen Icons. Beide Varianten führen zur Erstellung eines standardisierten Team-Eintrags mit Name, Farbcodes und einem SVG-basierten Icon. Der zugrunde liegende Code verarbeitet die Eingaben serverseitig, speichert das Ergebnis im Dateisystem und legt einen neuen Eintrag in der Datenbank an.

\subsubsection*{1. Wappen-Baukasten (Shield Builder)}

Der Benutzer durchläuft folgende Schritte:

\begin{enumerate}
  \item \textbf{Form auswählen}: SVG-Datei einer Wappenform
  \item \textbf{Muster auswählen}: Sechs vordefinierte Füllmuster (Pattern)
  \item \textbf{Farben definieren}: Zwei Farben via Color Picker (Iro.js)
  \item \textbf{Muster anpassen}: Zoom, Position per Drag \& Slider
  \item \textbf{Icon auswählen}: Aus Katalog oder eigener Upload
  \item \textbf{Icon anpassen}: Größe und Positionierung
  \item \textbf{Teamname eingeben}: Pflichtfeld
\end{enumerate}

\noindent Die Vorschau basiert auf einem \texttt{<svg>}-Element mit:
\begin{itemize}
  \item \textbf{ClipPath}: bestimmt die Wappenform
  \item \textbf{Pattern-Füllung}: SVG-Muster in ausgewählter Farbe und Position
  \item \textbf{Icon}: eingebettet als PNG oder SVG im Vordergrund
\end{itemize}

\subsubsection*{Formularverarbeitung}

Nach Klick auf „Speichern“ wird das finale SVG serialisiert und via Hidden Field (\texttt{final\_svg}) an den Server gesendet. Optional wird das hochgeladene Icon gespeichert. Die Daten werden als \texttt{TeamModel}-Instanz in der Datenbank abgelegt:

\begin{minted}{python}
new_team = TeamModel(
    name=name,
    icon=icon_path,
    primary_color=primary_color,
    secondary_color=secondary_color
)
\end{minted}

\subsubsection*{2. Direkter Icon-Upload (PNG oder SVG)}

Alternativ kann der Benutzer direkt ein Icon hochladen:

\begin{enumerate}
  \item \textbf{Datei hochladen}: PNG (mit Transparenz) oder SVG
  \item \textbf{Farben werden automatisch erkannt}: Farbdominanzanalyse per PIL (Python Imaging Library)
  \item \textbf{Farben bestätigen/anpassen}: Picker für Feinjustierung
  \item \textbf{Teamname eingeben}
\end{enumerate}

\subsubsection*{Farbanalyse (Backend)}

Bei Upload eines transparenten PNGs oder SVG wird serverseitig die dominanten Farben extrahiert:

\begin{minted}{python}
img = Image.open(file.stream).convert("RGBA")
pixels = [p for p in img.getdata() if p[3] > 0]
most_common = Counter(rgb_pixels).most_common(2)
hex_colors = [f"#{r:02x}{g:02x}{b:02x}" for r, g, b in [c[0] for c in most_common]]
\end{minted}

\noindent Die Farben werden anschließend im Formular angezeigt und können vom Benutzer überschrieben werden. Das SVG wird ähnlich wie im Builder erzeugt, allerdings ohne Wappenform, sondern auf dem gesamten Zeichenbereich.


\subsection{SVG-Generierung und Speicherung}

Unabhängig davon, ob ein Team per Baukasten oder per Direkt-Upload erstellt wird, resultiert der Vorgang stets in einem vollständigen \texttt{<svg>}-Bild, das serverseitig persistiert wird. Dieses SVG bildet das Herzstück der Teamdarstellung und enthält alle gestalterischen Informationen.

\begin{itemize}
  \item Das SVG umfasst die gesamte Gestaltung: gewählte Wappenform (\texttt{<path>}), Muster (\texttt{<pattern>}), Farbangaben, sowie das Icon als eingebettetes \texttt{<image>}-Element.
  \item Es wird dynamisch auf der Clientseite generiert und anschließend als Zeichenkette im versteckten Formularfeld \texttt{final\_svg} eingebunden.
  \item Auf Serverseite wird das SVG validiert und in einem benutzerspezifischen Verzeichnis unter dem Namen \texttt{team\_icon.svg} gespeichert.
  \item Zusätzliche \texttt{<clipPath>} und \texttt{<mask>}-Elemente sorgen für exakte Zuschnitte und klare Kanten innerhalb des Wappens.
  \item Die Dateiablage erfolgt im Ordnerpfad \texttt{/static/user\_created\_icons/<Teamname>/}.
\end{itemize}

\noindent Das so erzeugte SVG dient anschließend in der gesamten Anwendung als grafische Repräsentation des Teams, z.B. in Spielstatistiken, Listen oder Exportfunktionen.

\subsection{Validierung und Fehlermeldungen}

Das Formular zur Team-Erstellung unterliegt strikten Validierungsregeln, um die Konsistenz der Datenbankeinträge sicherzustellen. Jede Eingabe wird sowohl client- als auch serverseitig überprüft.

\begin{itemize}
  \item Alle Felder sind Pflichtfelder: Teamname, Primär- und Sekundärfarbe sowie das generierte oder hochgeladene SVG.
  \item Der Teamname muss eindeutig sein. Die entsprechende Spalte in der Datenbank ist mit \texttt{unique=True} versehen, um doppelte Einträge zu verhindern.
  \item Fehlerhafte oder unvollständige Eingaben führen zur Anzeige von Hinweisen mittels \texttt{flash()}-Nachrichten direkt in der Benutzeroberfläche.
  \item Falls beim Speichern neue Verzeichnisse erforderlich sind, z.B. für hochgeladene Icons, werden diese automatisch erzeugt (mittels \texttt{os.makedirs(..., exist\_ok=True)}).
  \item Zusätzlich werden Standardwerte validiert, etwa zulässige Bildformate oder die Existenz des übertragenen SVG-Inhalts.
\end{itemize}

\noindent Durch diese Maßnahmen wird sichergestellt, dass nur vollständige, valide und eindeutig benannte Teams in das System aufgenommen werden.




\end{document}
